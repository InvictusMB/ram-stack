const fs = require('fs');
const path = require('path');
const _ = require('lodash');
const os = require('os');

module.exports = function tsMacroDefinitionPlugin(options, compositionConfig) {
  const defaultTemplate = path.join(__dirname, 'definition.ts.template');
  const defaultOutputFilename = 'composition-root.d.ts';
  const {
    cwd,
    templateFilename = defaultTemplate,
    outputFilename = defaultOutputFilename,
  } = options;

  const rules = _.flow([
    _.partial(mapRegularRules, compositionConfig),
    _.partial(mapComposedRules, compositionConfig),
  ])({});

  const templatePath = getTemplatePath(cwd, defaultTemplate, templateFilename);
  const templateFile = fs.readFileSync(templatePath, 'utf-8');
  const eol = getEol(templateFile);

  const header = [
    '/* This file was automatically generated by ts-macro-definition plugin */',
    `/* See composition-config in ${formatPath(cwd)}/ */`,
    '\n',
  ].join('\n');

  const output = header + _.template(templateFile)({
    rules: Object.values(rules),
    cwd: formatPath(cwd),
  });

  const outputPath = path.join(cwd, outputFilename);
  fs.writeFileSync(outputPath, normalizeEol(output, eol), 'utf-8');
  console.log(`[ts-macro-definition] writing the output: ${formatPath(outputPath)}`);
};

function mapRegularRules(compositionConfig, processedRules) {
  const roots = Object.keys(compositionConfig.compositionRoots);

  return Object.entries(compositionConfig.rules).reduce((rules, [name, rule]) => {
    rules[name] = {
      name,
      roots: [],
      decorators: [],
    };
    _.forEach(roots, root => {
      const registration = rule.registrations && rule.registrations[root];
      if (!registration) {
        return;
      }
      rules[name].roots.push(root);
      rules[name].decorators = registration.decorators || [];
    });
    return rules;
  }, processedRules);
}

function mapComposedRules(compositionConfig, processedRules) {
  return Object.entries(compositionConfig.rules).reduce((rules, [name, rule]) => {
    if (!rule.compose) {
      return rules;
    }
    _.forEach(rule.compose, composed => {
      rules[name].roots = _.union(rules[name].roots, rules[composed].roots);
      rules[name].decorators = _.union(rules[name].decorators, rules[composed].decorators);
    });
    return rules;
  }, processedRules);
}

function getTemplatePath(cwd, defaultTemplate, templateFilename) {
  if (templateFilename === defaultTemplate) {
    console.log(`[ts-macro-definition] using the default template`);
    return templateFilename;
  }
  const templatePath = path.join(cwd, templateFilename);
  console.log(`[ts-macro-definition] reading the template: ${formatPath(templatePath)}`);
  return templatePath;
}

function formatPath(filePath) {
  return './' + path.normalize(path.relative(process.cwd(), filePath)).replace(path.sep, '/');
}

function getEol(text) {
  const matches = text.match(/\r\n|\n/g) || [];
  const unix = matches.filter(a => a === '\n').length;
  const win = matches.length - unix;
  if (unix === win) {
    return os.EOL;
  }
  return unix > win ? '\n' : '\r\n';
}

function normalizeEol(text, eol) {
  return text.replace(/\r\n|\n/g, eol);
}
